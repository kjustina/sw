#include <stdio.h>
#include <iostream>
#include <gtest/gtest.h>

#include <boost/crc.hpp>
#include "boost/property_tree/json_parser.hpp"
#include "nic/sdk/model_sim/include/lib_model_client.h"
#include "sdk/pal.hpp"
#include "sdk/utils.hpp"
#include "sdk/types.hpp"
#include "nic/hal/pd/capri/capri_config.hpp"
#include "nic/sdk/asic/cmn/asic_hbm.hpp"
#include "nic/sdk/lib/p4/p4_api.hpp"
#include "nic/gen/apollo/include/p4pd.h"
#include "nic/p4/apollo/include/defines.h"
#include "nic/p4/apollo/include/slacl_defines.h"
#include "nic/hal/pd/asicpd/asic_pd_common.hpp"
#include "nic/hal/pd/asic_pd.hpp"
#include "nic/sdk/asic/asic.hpp"
#include "nic/utils/pack_bytes/pack_bytes.hpp"
#include "nic/hal/pd/globalpd/gpd_utils.hpp"

hal_ret_t capri_default_config_init(asic_cfg_t *cfg);

#define VLAN_ID 100
#define VNIC_ID 10

// packets generated by tools/apollo_test.py
uint8_t g_snd_pkt1[] = {
    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x00, 0xA1,
    0xA2, 0xA3, 0xA4, 0xA5, 0x81, 0x00, 0x00, 0x64,
    0x08, 0x00, 0x45, 0x00, 0x00, 0x5C, 0x00, 0x01,
    0x00, 0x00, 0x40, 0x06, 0x62, 0x8D, 0x0B, 0x01,
    0x02, 0x03, 0x0A, 0x0A, 0x01, 0x01, 0x03, 0xFF,
    0x00, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x50, 0x02, 0x20, 0x00, 0x56, 0x1A,
    0x00, 0x00, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66,
    0x67, 0x68, 0x69, 0x6A, 0x6C, 0x6B, 0x6D, 0x6E,
    0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76,
    0x77, 0x7A, 0x78, 0x79, 0x61, 0x62, 0x63, 0x64,
    0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6C, 0x6B,
    0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73, 0x74,
    0x75, 0x76, 0x77, 0x7A, 0x78, 0x79};

uint8_t g_rcv_pkt1[] = {
    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x00, 0xA1,
    0xA2, 0xA3, 0xA4, 0xA5, 0x81, 0x00, 0x00, 0x64,
    0x08, 0x00, 0x45, 0x00, 0x00, 0x5C, 0x00, 0x01,
    0x00, 0x00, 0x40, 0x06, 0x62, 0x8D, 0x0B, 0x01,
    0x02, 0x03, 0x0A, 0x0A, 0x01, 0x01, 0x03, 0xFF,
    0x00, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x50, 0x02, 0x20, 0x00, 0x56, 0x1A,
    0x00, 0x00, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66,
    0x67, 0x68, 0x69, 0x6A, 0x6C, 0x6B, 0x6D, 0x6E,
    0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76,
    0x77, 0x7A, 0x78, 0x79, 0x61, 0x62, 0x63, 0x64,
    0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6C, 0x6B,
    0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73, 0x74,
    0x75, 0x76, 0x77, 0x7A, 0x78, 0x79};

uint8_t g_snd_pkt2[] = {
    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x00, 0xA1,
    0xA2, 0xA3, 0xA4, 0xA5, 0x81, 0x00, 0x00, 0x64,
    0x08, 0x00, 0x45, 0x00, 0x00, 0x50, 0x00, 0x01,
    0x00, 0x00, 0x40, 0x11, 0x61, 0x83, 0x0A, 0x0A,
    0x02, 0x03, 0x0B, 0x0B, 0x02, 0x02, 0x27, 0x10,
    0x04, 0xD2, 0x00, 0x3C, 0x9D, 0x43, 0x61, 0x62,
    0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A,
    0x6C, 0x6B, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72,
    0x73, 0x74, 0x75, 0x76, 0x77, 0x7A, 0x78, 0x79,
    0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68,
    0x69, 0x6A, 0x6C, 0x6B, 0x6D, 0x6E, 0x6F, 0x70,
    0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x7A,
    0x78, 0x79
    };

uint8_t g_rcv_pkt2[] = {
    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x00, 0xA1,
    0xA2, 0xA3, 0xA4, 0xA5, 0x81, 0x00, 0x00, 0x64,
    0x08, 0x00, 0x45, 0x00, 0x00, 0x50, 0x00, 0x01,
    0x00, 0x00, 0x40, 0x11, 0x61, 0x83, 0x0A, 0x0A,
    0x02, 0x03, 0x0B, 0x0B, 0x02, 0x02, 0x27, 0x10,
    0x04, 0xD2, 0x00, 0x3C, 0x9D, 0x43, 0x61, 0x62,
    0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A,
    0x6C, 0x6B, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72,
    0x73, 0x74, 0x75, 0x76, 0x77, 0x7A, 0x78, 0x79,
    0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68,
    0x69, 0x6A, 0x6C, 0x6B, 0x6D, 0x6E, 0x6F, 0x70,
    0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x7A,
    0x78, 0x79
    };

uint8_t g_snd_pkt3[] = {
    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x00, 0xA1,
    0xA2, 0xA3, 0xA4, 0xA5, 0x81, 0x00, 0x00, 0x64,
    0x08, 0x00, 0x45, 0x00, 0x00, 0x8E, 0x00, 0x00,
    0x00, 0x00, 0x40, 0x11, 0xAD, 0x57, 0x65, 0x01,
    0x02, 0x03, 0x64, 0x01, 0x02, 0x03, 0x00, 0x35,
    0x12, 0xB5, 0x00, 0x7A, 0x00, 0x00, 0x08, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF1,
    0xF2, 0xF3, 0xF4, 0xF5, 0x00, 0xA1, 0xA2, 0xA3,
    0xA4, 0xA5, 0x08, 0x00, 0x45, 0x00, 0x00, 0x5C,
    0x00, 0x01, 0x00, 0x00, 0x40, 0x06, 0x62, 0x8D,
    0x0B, 0x01, 0x02, 0x03, 0x0A, 0x0A, 0x01, 0x01,
    0x03, 0xFF, 0x00, 0x50, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x50, 0x02, 0x20, 0x00,
    0x56, 0x1A, 0x00, 0x00, 0x61, 0x62, 0x63, 0x64,
    0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6C, 0x6B,
    0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73, 0x74,
    0x75, 0x76, 0x77, 0x7A, 0x78, 0x79, 0x61, 0x62,
    0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A,
    0x6C, 0x6B, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72,
    0x73, 0x74, 0x75, 0x76, 0x77, 0x7A, 0x78, 0x79
    };

uint8_t g_rcv_pkt3[] = {
    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x00, 0xA1,
    0xA2, 0xA3, 0xA4, 0xA5, 0x81, 0x00, 0x00, 0x64,
    0x08, 0x00, 0x45, 0x00, 0x00, 0x8E, 0x00, 0x00,
    0x00, 0x00, 0x40, 0x11, 0xAD, 0x57, 0x65, 0x01,
    0x02, 0x03, 0x64, 0x01, 0x02, 0x03, 0x00, 0x35,
    0x12, 0xB5, 0x00, 0x7A, 0x00, 0x00, 0x08, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF1,
    0xF2, 0xF3, 0xF4, 0xF5, 0x00, 0xA1, 0xA2, 0xA3,
    0xA4, 0xA5, 0x08, 0x00, 0x45, 0x00, 0x00, 0x5C,
    0x00, 0x01, 0x00, 0x00, 0x40, 0x06, 0x62, 0x8D,
    0x0B, 0x01, 0x02, 0x03, 0x0A, 0x0A, 0x01, 0x01,
    0x03, 0xFF, 0x00, 0x50, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x50, 0x02, 0x20, 0x00,
    0x56, 0x1A, 0x00, 0x00, 0x61, 0x62, 0x63, 0x64,
    0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6C, 0x6B,
    0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73, 0x74,
    0x75, 0x76, 0x77, 0x7A, 0x78, 0x79, 0x61, 0x62,
    0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A,
    0x6C, 0x6B, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72,
    0x73, 0x74, 0x75, 0x76, 0x77, 0x7A, 0x78, 0x79
    };

uint8_t g_snd_pkt4[] = {
    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x00, 0xA1,
    0xA2, 0xA3, 0xA4, 0xA5, 0x81, 0x00, 0x00, 0x64,
    0x08, 0x00, 0x45, 0x00, 0x00, 0x82, 0x00, 0x00,
    0x00, 0x00, 0x40, 0x11, 0xAD, 0x63, 0x65, 0x01,
    0x02, 0x03, 0x64, 0x01, 0x02, 0x03, 0x00, 0x35,
    0x12, 0xB5, 0x00, 0x6E, 0x00, 0x00, 0x08, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF1,
    0xF2, 0xF3, 0xF4, 0xF5, 0x00, 0xB1, 0xB2, 0xB3,
    0xB4, 0xB5, 0x08, 0x00, 0x45, 0x00, 0x00, 0x50,
    0x00, 0x01, 0x00, 0x00, 0x40, 0x11, 0x61, 0x83,
    0x0A, 0x0A, 0x02, 0x03, 0x0B, 0x0B, 0x02, 0x02,
    0x27, 0x10, 0x04, 0xD2, 0x00, 0x3C, 0x9D, 0x43,
    0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68,
    0x69, 0x6A, 0x6C, 0x6B, 0x6D, 0x6E, 0x6F, 0x70,
    0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x7A,
    0x78, 0x79, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66,
    0x67, 0x68, 0x69, 0x6A, 0x6C, 0x6B, 0x6D, 0x6E,
    0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76,
    0x77, 0x7A, 0x78, 0x79
    };

uint8_t g_rcv_pkt4[] = {
    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x00, 0xA1,
    0xA2, 0xA3, 0xA4, 0xA5, 0x81, 0x00, 0x00, 0x64,
    0x08, 0x00, 0x45, 0x00, 0x00, 0x82, 0x00, 0x00,
    0x00, 0x00, 0x40, 0x11, 0xAD, 0x63, 0x65, 0x01,
    0x02, 0x03, 0x64, 0x01, 0x02, 0x03, 0x00, 0x35,
    0x12, 0xB5, 0x00, 0x6E, 0x00, 0x00, 0x08, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF1,
    0xF2, 0xF3, 0xF4, 0xF5, 0x00, 0xB1, 0xB2, 0xB3,
    0xB4, 0xB5, 0x08, 0x00, 0x45, 0x00, 0x00, 0x50,
    0x00, 0x01, 0x00, 0x00, 0x40, 0x11, 0x61, 0x83,
    0x0A, 0x0A, 0x02, 0x03, 0x0B, 0x0B, 0x02, 0x02,
    0x27, 0x10, 0x04, 0xD2, 0x00, 0x3C, 0x9D, 0x43,
    0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68,
    0x69, 0x6A, 0x6C, 0x6B, 0x6D, 0x6E, 0x6F, 0x70,
    0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x7A,
    0x78, 0x79, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66,
    0x67, 0x68, 0x69, 0x6A, 0x6C, 0x6B, 0x6D, 0x6E,
    0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76,
    0x77, 0x7A, 0x78, 0x79
    };

class apollo_test : public ::testing::Test {
  protected:
    apollo_test() {}
    virtual ~apollo_test() {}
    virtual void SetUp() {}
    virtual void TearDown() {}
};


static void
entry_write(uint32_t tbl_id, uint32_t index, void *key, void *mask, void *data)
{
    if (key || mask) {
        // prepare entry and write hardware
        uint32_t hwkey_len = 0;
        uint32_t hwmask_len = 0;
        uint32_t hwdata_len = 0;
        uint8_t  *hwkey = NULL;
        uint8_t  *hwmask = NULL;
        p4pd_hwentry_query(tbl_id, &hwkey_len, &hwmask_len,
                           &hwdata_len);
        hwkey_len = (hwkey_len >> 3) + ((hwkey_len & 0x7) ? 1 : 0);
        hwmask_len = (hwmask_len >> 3) + ((hwmask_len & 0x7) ? 1 : 0);
        hwdata_len = (hwdata_len >> 3) + ((hwdata_len & 0x7) ? 1 : 0);
        hwkey = new uint8_t[hwkey_len];
        hwmask = new uint8_t[hwmask_len];
        memset(hwkey, 0, hwkey_len);
        memset(hwmask, 0, hwmask_len);
        p4pd_hwkey_hwmask_build(tbl_id, key, mask,
                                hwkey, hwmask);
        p4pd_entry_write(tbl_id, index, hwkey, hwmask, data);
        delete [] hwkey;
        delete [] hwmask;
    } else {
        p4pd_entry_write(tbl_id, index, NULL, NULL, data);
    }
}

static void
vnic_init (void)
{
    vnic_actiondata_t data;
    vnic_vnic_mapping_t *vnic_mapping = &data.action_u.vnic_vnic_mapping;
    uint64_t slacl_hbm_addr;
    uint64_t lpm_hbm_addr;
    uint32_t vid = VLAN_ID;
    uint32_t index;
    uint32_t tbl_id = P4TBL_ID_VNIC;

    memset(&data, 0, sizeof(data));
    index = vid;
    data.action_id = VNIC_VNIC_MAPPING_ID;
    vnic_mapping->vnic = VNIC_ID;
    slacl_hbm_addr = asicpd_get_mem_addr("slacl");
    memcpy(vnic_mapping->slacl_addr_1, &slacl_hbm_addr, sizeof(vnic_mapping->slacl_addr_1));
    lpm_hbm_addr = asicpd_get_mem_addr("lpm");
    memcpy(vnic_mapping->lpm_addr_1, &lpm_hbm_addr, sizeof(vnic_mapping->lpm_addr_1));

    std::cout << std::endl << std::endl
              << "VNIC init "
              << " vlan " << index
              << " vnic id " << vnic_mapping->vnic
              << " slacl HBM addr 0x" << std::hex << slacl_hbm_addr << std::dec
              << " lpm HBM addr 0x" << std::hex << lpm_hbm_addr << std::dec
              << std::endl << std::endl;

    entry_write(tbl_id, index, NULL, NULL, &data);
}

static void
key_native_init (void)
{
    key_native_swkey_t key;
    key_native_swkey_mask_t mask;
    key_native_actiondata_t data;
    uint32_t tbl_id = P4TBL_ID_KEY_NATIVE;
    uint32_t index;

    memset(&key, 0, sizeof(key));
    memset(&mask, 0, sizeof(mask));
    memset(&data, 0, sizeof(data));

    index = 0;
    data.action_id = KEY_NATIVE_NATIVE_IPV4_PACKET_ID;
    key.tunnel_metadata_tunnel_type = INGRESS_TUNNEL_TYPE_NONE;
    mask.tunnel_metadata_tunnel_type_mask = 0xff;
    key.ipv4_1_valid = 1;
    mask.ipv4_1_valid_mask = 1;

    entry_write(tbl_id, index, &key, &mask, &data);
}

static void
key_tunneled_init (void)
{
    key_tunneled_swkey_t key;
    key_tunneled_swkey_mask_t mask;
    key_tunneled_actiondata_t data;
    uint32_t tbl_id = P4TBL_ID_KEY_TUNNELED;
    uint32_t index;

    memset(&key, 0, sizeof(key));
    memset(&mask, 0, sizeof(mask));
    memset(&data, 0, sizeof(data));

    index = 0;
    data.action_id = KEY_TUNNELED_TUNNELED_IPV4_PACKET_ID;
    key.tunnel_metadata_tunnel_type = INGRESS_TUNNEL_TYPE_VXLAN;
    mask.tunnel_metadata_tunnel_type_mask = 0xff;
    key.ipv4_2_valid = 1;
    mask.ipv4_2_valid_mask = 1;

    entry_write(tbl_id, index, &key, &mask, &data);
}

#define C0_WIDTH 10
#define C1_WIDTH 10
#define C2_WIDTH 8
#define C3_WIDTH 8
#define C4_WIDTH 4
#define C5_WIDTH 10
#define C6_WIDTH 10
#define C7_WIDTH 10
#define RESULT_WIDTH 16

static void
get_slacl_addr_offset (uint32_t tbl_id, uint32_t index,
                       uint64_t *addr, uint32_t *start_bit, uint32_t *len,
                       uint32_t *word_bytes_p)
{
    uint64_t hbm_base_addr = asicpd_get_mem_addr("slacl");
    uint64_t offset;
    uint32_t num_entries_packed = 1;
    uint32_t entry_width;
    uint32_t word_bytes = 64;

    switch(tbl_id) {
        case P4TBL_ID_SLACL_IP_31_16:
            offset = 0;
            entry_width = C0_WIDTH;
            break;
        case P4TBL_ID_SLACL_IP_15_00:
            offset = SLACL_IP_TABLE_OFFSET;
            entry_width = C1_WIDTH;
            break;
        case P4TBL_ID_SLACL_SPORT:
            offset = SLACL_SPORT_TABLE_OFFSET;
            entry_width = C2_WIDTH;
            word_bytes = 1;
            break;
        case P4TBL_ID_SLACL_DPORT:
            offset = SLACL_DPORT_TABLE_OFFSET;
            entry_width = C3_WIDTH;
            word_bytes = 1;
            break;
        case P4TBL_ID_SLACL_PROTO:
            offset = SLACL_PROTO_TABLE_OFFSET;
            entry_width = C4_WIDTH;
            word_bytes = 1;
            break;
        case P4TBL_ID_SLACL_P1_C0C2:
            offset = SLACL_P1_C0C2_TABLE_OFFSET;
            entry_width = C5_WIDTH;
            break;
        case P4TBL_ID_SLACL_P1_C1C3:
            offset = SLACL_P1_C1C3_TABLE_OFFSET;
            entry_width = C6_WIDTH;
            break;
        case P4TBL_ID_SLACL_P2_C6C4:
            offset = SLACL_P2_C6C4_TABLE_OFFSET;
            entry_width = C7_WIDTH;
            break;
        case P4TBL_ID_SLACL_P3:
            offset = SLACL_P3_TABLE_OFFSET;
            entry_width = RESULT_WIDTH;
            word_bytes = 2;
            break;
        default:
            ASSERT_TRUE(0);
    }

    num_entries_packed = (word_bytes<<3)/entry_width;
    *addr = hbm_base_addr + offset + ((index/num_entries_packed) * word_bytes);
    *start_bit = (index%num_entries_packed)*entry_width;
    *len = entry_width;
    *word_bytes_p = word_bytes;
}

static void
slacl_entry_write(uint32_t tbl_id, uint32_t index, uint32_t val)
{
    // Raw HBM data, 64 bytes
    uint8_t data[64];
    uint32_t start_bit, len;
    uint64_t addr;
    uint32_t word_bytes;

    get_slacl_addr_offset(tbl_id, index, &addr, &start_bit, &len, &word_bytes);

    // Read modify write
    hal::pd::asic_mem_read(addr, data, word_bytes);
    // Modify the data bits
    hal::pd::memrev(data, word_bytes);
    hal::utils::pack_bytes_pack(data, start_bit, len, val);
    hal::pd::memrev(data, word_bytes);
    hal::pd::asic_mem_write(addr, data, word_bytes);

    std::cout << std::endl << std::endl
              << "SLACL entry write "
              << " tbl_id " << tbl_id
              << " index 0x" << std::hex << index << std::dec
              << " val 0x" << std::hex << val << std::dec
              << " HBM addr 0x" << std::hex << addr << std::dec
              << " start_bit " << start_bit
              << std::endl << std::endl;

}

static uint32_t
encode_rule_result (uint32_t rule_id, uint32_t drop)
{
    // 5 bits of padding
    return ((rule_id << 1) | drop) << 5;
}

static void
slacl_init (void)
{
    uint32_t c0, c1, c2, c3, c4, c5, c6, c7;
    uint32_t drop;
    uint32_t rule_id;

    // Add an entry for 10.10.1.1/1023/80/TCP - Permit
    rule_id = 0xab;
    drop = 0;
    c0 = 0x2ce;
    c1 = 20;
    c2 = 30;
    c3 = 40;
    c4 = 1;
    c5 = 50;
    c6 = 60;
    c7 = 70;

    slacl_entry_write(P4TBL_ID_SLACL_IP_31_16, 0x0a0a, c0);
    slacl_entry_write(P4TBL_ID_SLACL_IP_15_00, 0x0101, c1);
    slacl_entry_write(P4TBL_ID_SLACL_SPORT, 1023, c2);
    slacl_entry_write(P4TBL_ID_SLACL_DPORT, 80, c3);
    slacl_entry_write(P4TBL_ID_SLACL_PROTO, IP_PROTO_TCP, c4);

    slacl_entry_write(P4TBL_ID_SLACL_P1_C0C2, (c0<<C2_WIDTH) | c2, c5);
    slacl_entry_write(P4TBL_ID_SLACL_P1_C1C3, (c1<<C3_WIDTH) | c3, c6);

    slacl_entry_write(P4TBL_ID_SLACL_P2_C6C4, (c6<<C4_WIDTH) | c4, c7);

    slacl_entry_write(P4TBL_ID_SLACL_P3, (c5<<C7_WIDTH) | c7,
                      encode_rule_result(rule_id, drop));

    // Rule 2
    // Add an entry for 11.11.2.2/10000/1234/UDP - Deny
    rule_id = 0x58;
    drop = 1;
    c0 = 110;
    c1 = 120;
    c2 = 130;
    c3 = 140;
    c4 = 2;
    c5 = 150;
    c6 = 160;
    c7 = 170;

    slacl_entry_write(P4TBL_ID_SLACL_IP_31_16, 0x0b0b, c0);
    slacl_entry_write(P4TBL_ID_SLACL_IP_15_00, 0x0202, c1);
    slacl_entry_write(P4TBL_ID_SLACL_SPORT, 10000, c2);
    slacl_entry_write(P4TBL_ID_SLACL_DPORT, 1234, c3);
    slacl_entry_write(P4TBL_ID_SLACL_PROTO, IP_PROTO_UDP, c4);

    slacl_entry_write(P4TBL_ID_SLACL_P1_C0C2, (c0<<C2_WIDTH) | c2, c5);
    slacl_entry_write(P4TBL_ID_SLACL_P1_C1C3, (c1<<C3_WIDTH) | c3, c6);

    slacl_entry_write(P4TBL_ID_SLACL_P2_C6C4, (c6<<C4_WIDTH) | c4, c7);

    slacl_entry_write(P4TBL_ID_SLACL_P3, (c5<<C7_WIDTH) | c7,
                      encode_rule_result(rule_id, drop));
}

TEST_F(apollo_test, test1) {
    int ret = 0;
    uint64_t asm_base_addr;
    p4pd_cfg_t    p4pd_cfg = {
        .table_map_cfg_file = "apollo/p4_table_map.json",
        .p4pd_pgm_name = "apollo",
        .cfg_path = std::getenv("HAL_CONFIG_PATH")
    };
    const char *hal_conf_file = "conf/hal.json";
    char *default_config_dir = NULL;
    asic_cfg_t cfg;
    sdk::lib::catalog    *catalog;

    printf("Connecting to ASIC SIM\n");
    hal::utils::trace_init("hal", 0, true, "hal.log",
                           TRACE_FILE_SIZE_DEFAULT, TRACE_NUM_FILES_DEFAULT,
                           ::utils::trace_debug);

    ret = sdk::lib::pal_init(platform_type_t::PLATFORM_TYPE_SIM);
    ASSERT_NE(ret, -1);
    ret = capri_load_config((char *)"obj/apollo/pgm_bin");
    ASSERT_NE(ret, -1);
    cfg.cfg_path = std::string(std::getenv("HAL_CONFIG_PATH"));
    cfg.pgm_name = "apollo";
    if (getenv("HAL_PLATFORM_MODE_RTL")) {
        hal_conf_file = "conf/hal_apollo_rtl.json";
    }

    asm_base_addr = (uint64_t) asicpd_get_mem_addr((char *)JP4_PRGM);
    ret = capri_load_mpu_programs("apollo", (char *)"obj/apollo/asm_bin",
                                  asm_base_addr, NULL, 0, NULL);
    ASSERT_NE(ret, -1);
    std::ifstream json_cfg(hal_conf_file);
    ret = p4pd_init(&p4pd_cfg);
    ASSERT_NE(ret, -1);
    ret = sdk::asic::pd::asicpd_table_rw_init(NULL);
    ASSERT_NE(ret, -1);
    ret = capri_hbm_cache_init(NULL);
    ASSERT_NE(ret, -1);
    ret = capri_hbm_cache_regions_init();
    ASSERT_NE(ret, -1);
    ret = hal::pd::asicpd_table_mpu_base_init(&p4pd_cfg);
    ASSERT_NE(ret, -1);
    ret = hal::pd::asicpd_program_table_mpu_pc();
    ASSERT_NE(ret, -1);
    ret = hal::pd::asicpd_deparser_init();
    ASSERT_NE(ret, -1);
    ret = hal::pd::asicpd_program_hbm_table_base_addr();
    ASSERT_NE(ret, -1);

    catalog = sdk::lib::catalog::factory(cfg.cfg_path, "/catalog.json");
    ASSERT_TRUE(catalog != NULL);

    if (!catalog->qos_sw_init_enabled()) {
        default_config_dir = std::getenv("HAL_PBC_INIT_CONFIG");
        if (default_config_dir) {
            cfg.default_config_dir = std::string(default_config_dir);
        } else {
            cfg.default_config_dir = "8x25_hbm";
        }
        ret = capri_default_config_init(&cfg);
    }
    ASSERT_NE(ret, -1);
    ret = capri_tm_init(catalog);
    ASSERT_NE(ret, -1);

    config_done();

    key_native_init();
    key_tunneled_init();
    vnic_init();
    slacl_init();

    // Send pkts
    uint32_t i = 0;
    uint32_t port = 0;
    uint32_t cos = 0;
    std::vector<uint8_t> ipkt;
    std::vector<uint8_t> opkt;
    std::vector<uint8_t> epkt;
    uint32_t tcscale = 1;
    int tcid = 0;
    int tcid_filter = 0;
    uint32_t tx_enable = 0;
    (void)tx_enable;
    uint32_t rx_enable = 0;

    if (getenv("TCSCALE")) {
        tcscale = atoi(getenv("TCSCALE"));
    }

    if (getenv("APOLLO_TEST_TX_ONLY")) {
        tx_enable = atoi(getenv("APOLLO_TEST_TX_ONLY"));
    }

    if (getenv("APOLLO_TEST_RX_ONLY")) {
        rx_enable = atoi(getenv("APOLLO_TEST_RX_ONLY"));
    }

    // Run all tests, if none of these are set.
    if (!getenv("APOLLO_TEST_TX_ONLY") && !getenv("APOLLO_TEST_RX_ONLY")) {
        rx_enable = 1;
        tx_enable = 1;
    }

    if (getenv("APOLLO_TCID")) {
        tcid_filter = atoi(getenv("APOLLO_TCID"));
    }

    tcid++;
    if (rx_enable && (tcid_filter == 0 || tcid == tcid_filter)) {
        ipkt.resize(sizeof(g_snd_pkt1));
        memcpy(ipkt.data(), g_snd_pkt1, sizeof(g_snd_pkt1));
        epkt.resize(sizeof(g_rcv_pkt1));
        memcpy(epkt.data(), g_rcv_pkt1, sizeof(g_rcv_pkt1));
        std::cout << "Rx: Testing slacl rule 1 native pkt" << std::endl;
        for (i = 0; i < tcscale; i++) {
            printf("Starting Testcase TC%06d-%04d\n", tcid, i+1);
            testcase_begin(tcid, i+1);
            step_network_pkt(ipkt, port);
            if (!getenv("SKIP_VERIFY")) {
                get_next_pkt(opkt, port, cos);
                EXPECT_TRUE(opkt == epkt);
            }
            testcase_end(tcid, i+1);
        }
    }

    tcid++;
    if (rx_enable && (tcid_filter == 0 || tcid == tcid_filter)) {
        ipkt.resize(sizeof(g_snd_pkt2));
        memcpy(ipkt.data(), g_snd_pkt2, sizeof(g_snd_pkt2));
        epkt.resize(sizeof(g_rcv_pkt2));
        memcpy(epkt.data(), g_rcv_pkt2, sizeof(g_rcv_pkt2));
        std::cout << "Rx: Testing slacl rule 2 native pkt" << std::endl;
        for (i = 0; i < tcscale; i++) {
            printf("Starting Testcase TC%06d-%04d\n", tcid, i+1);
            testcase_begin(tcid, i+1);
            step_network_pkt(ipkt, port);
            if (!getenv("SKIP_VERIFY")) {
                get_next_pkt(opkt, port, cos);
                EXPECT_TRUE(opkt == epkt);
            }
            testcase_end(tcid, i+1);
        }
    }

    tcid++;
    if (rx_enable && (tcid_filter == 0 || tcid == tcid_filter)) {
        ipkt.resize(sizeof(g_snd_pkt3));
        memcpy(ipkt.data(), g_snd_pkt3, sizeof(g_snd_pkt3));
        epkt.resize(sizeof(g_rcv_pkt3));
        memcpy(epkt.data(), g_rcv_pkt3, sizeof(g_rcv_pkt3));
        std::cout << "Rx: Testing slacl rule 1 vxlan pkt" << std::endl;
        for (i = 0; i < tcscale; i++) {
            printf("Starting Testcase TC%06d-%04d\n", tcid, i+1);
            testcase_begin(tcid, i+1);
            step_network_pkt(ipkt, port);
            if (!getenv("SKIP_VERIFY")) {
                get_next_pkt(opkt, port, cos);
                EXPECT_TRUE(opkt == epkt);
            }
            testcase_end(tcid, i+1);
        }
    }

    tcid++;
    if (rx_enable && (tcid_filter == 0 || tcid == tcid_filter)) {
        ipkt.resize(sizeof(g_snd_pkt4));
        memcpy(ipkt.data(), g_snd_pkt4, sizeof(g_snd_pkt4));
        epkt.resize(sizeof(g_rcv_pkt4));
        memcpy(epkt.data(), g_rcv_pkt4, sizeof(g_rcv_pkt4));
        std::cout << "Rx: Testing slacl rule 2 vxlan pkt" << std::endl;
        for (i = 0; i < tcscale; i++) {
            printf("Starting Testcase TC%06d-%04d\n", tcid, i+1);
            testcase_begin(tcid, i+1);
            step_network_pkt(ipkt, port);
            if (!getenv("SKIP_VERIFY")) {
                get_next_pkt(opkt, port, cos);
                EXPECT_TRUE(opkt == epkt);
            }
            testcase_end(tcid, i+1);
        }
    }

    exit_simulation();
}

int main(int argc, char **argv) {
    ::testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}
